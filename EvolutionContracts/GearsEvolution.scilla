(* SPDX-License-Identifier: MIT *)
scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import BoolUtils ListUtils IntUtils
library GearsEvolution

(* Global variables *)
let zero_address = 0x0000000000000000000000000000000000000000
let false = False
let true = True


(* Error exception *)
type Error =
  | NotAdminError
  | InvalidCallbackSender
  | NotContractOwnerError
  | AdminFoundError

let make_error =
  fun (result: Error) =>
    let result_code =
      match result with
      | NotAdminError                     => Int32 -1
      | InvalidCallbackSender             => Int32 -2
      | NotContractOwnerError             => Int32 -3
      | AdminFoundError                   => Int32 -4
      end
    in
    { _exception: "Error"; code: result_code }


(* Library functions *)
let one_msg =
  fun (msg: Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let two_msgs =
  fun (msg1: Message) =>
  fun (msg2: Message) =>
    let msgs_tmp = one_msg msg2 in
    Cons {Message} msg1 msgs_tmp

let three_msgs =
  fun (msg1: Message) =>
  fun (msg2: Message) =>
  fun (msg3: Message) =>
    let msgs_tmp = two_msgs msg2 msg3 in
    Cons {Message} msg1 msgs_tmp
(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract GearsEvolution
(
  initial_contract_owner: ByStr20,
  token: ByStr20 with contract field token_uris: Map Uint256 String, field token_owners: Map Uint256 ByStr20 end
)


(* Mutable fields *)
(* Set for admins
  initial_contract_owner is the admin by default *)
field admins: Map ByStr20 Bool = 
  let emp_map = Emp ByStr20 Bool in
  builtin put emp_map initial_contract_owner true

(* Contract Owner *)
(* Defaults to `initial_contract_owner` *)
field contract_owner: ByStr20 = initial_contract_owner


(* Procedures *)
(* Emit Errors *)
procedure Throw(error: Error)
  e = make_error error;
  throw e
end

(* Check is the address is admin or not *)
procedure IsAdmin()
  has_admin <- exists admins[_sender];
  match has_admin with
  | True =>
  | False =>
    error = NotAdminError;
    Throw error
  end
end

procedure RequireContractOwner()
  cur_owner <- contract_owner;
  is_contract_owner = builtin eq cur_owner _sender;
  match is_contract_owner with
  | True => 
  | False =>
    error = NotContractOwnerError;
    Throw error
  end
end

(* Transitions *)
transition EvolveGears(id_lv_max: Uint256, id_lv_any: Uint256) 
  (* IsAdmin; *)
  max_token_uri <- & token.token_uris[id_lv_max];
  any_token_uri <- & token.token_uris[id_lv_any];
  to <- & token.token_owners[id_lv_max];
  e = {
    _eventname: "EvolveGears";
    max_token_uri: max_token_uri;
    any_token_uri: any_token_uri;
    to: to;
    id_lv_max: id_lv_max;
    id_lv_any: id_lv_any
  };
  event e
end

transition EvolveGearsCallback(token_uri: String, to: ByStr20, id_lv_max: Uint256, id_lv_any: Uint256)
  (* This call back must be invoked by the NFT contract *)
  (* IsAdmin; *)
  (* Burn old NFTs here *)
  (* msg_one = {
    _tag: "Burn";
    _recipient: token;
    _amount: Uint128 0;
    token_id: id_lv_max
  };
  msg_two = {
    _tag: "Burn";
    _recipient: token;
    _amount: Uint128 0;
    token_id: id_lv_any
  }; *)
  msg_three = {
    _tag: "Mint";
    _recipient: token;
    _amount: Uint128 0;
    to: to;
    token_uri: token_uri
  };
  msgs = one_msg msg_three;
  send msgs;
  e = {(* SPDX-License-Identifier: MIT *)
    scilla_version 0
    
    (***************************************************)
    (*               Associated library                *)
    (***************************************************)
    import IntUtils ListUtils 
    
    library Staking
    let one = Uint256 1
    let zero = Uint128 0
    let ten = Uint256 10
    let true = True
    let false = False
    let empty_string = ""
    let one_msg = 
        fun (msg : Message) => 
            let nil_msg = Nil {Message} in
            Cons {Message} msg nil_msg   
    
    (* Dummy user-defined ADT *)
    (* stakedAmount, unstakedAmount, rewardAmount *)
    type Record = 
    | Record of Uint256 Uint256 Uint256
    
    
    type Error =
    | CodeIsOwner
    | CodeIsSameBlock
    | CodeIsHeroesNotSet
    | CodeIsDlHeroesNotSet
    | CodeIsGearsNotSet
    
    let make_error =
        fun (result : Error) =>
            let result_code = 
            match result with
            | CodeIsOwner                => Int32 -1
            | CodeIsSameBlock            => Int32 -2
            | CodeIsHeroesNotSet         => Int32 -3 
            | CodeIsDlHeroesNotSet       => Int32 -4
            | CodeIsGearsNotSet          => Int32 -5
            end
            in
            { _exception : "Error"; code : result_code }
    
    (***************************************************)
    (*             The contract definition             *)
    (***************************************************)
    contract Staking 
    (
        contract_owner: ByStr20,
        reward_token: ByStr20 with contract field balances: Map ByStr20 Uint128 end
    )
    
    (* Mutable fields *)
    field oracleAddress: Option ByStr20 = None {ByStr20}
    
    
    (* Mapping for caller Address to BlockNumber *)
    field caller_block_num: Map ByStr20 BNum = Emp ByStr20 BNum
    
    (* Mapping for token address to yse addresses to an User Record  *)
    field records: Map ByStr20 (Map ByStr20 Record) = Emp ByStr20 (Map ByStr20 Record)
    (**************************************)
    (*             Procedures             *)
    (**************************************)
    
    procedure ThrowError(error: Error)
        e = make_error error;
        throw e
    end
    
    
    procedure IsSameBlock(blk: BNum)
        last_blk <- caller_block_num[_sender];
        match last_blk with
        | Some v =>
            is_allowed = builtin blt v blk;
            match is_allowed with
            | False =>
                err = CodeIsSameBlock;
                ThrowError err
            | True =>
            end
        | None =>
        end
    end
    
    
    procedure IsNotOwner(address: ByStr20)
        is_owner = builtin eq contract_owner address;
        match is_owner with
        | False =>
            err = CodeIsOwner;
            ThrowError err
        | True =>
        end
    end
    
    (***************************************)
    (*             Transitions             *)
    (***************************************)
    
    
    
    _eventname: "NFT Evolved";
    id_lv_max: id_lv_max;
    id_lv_any: id_lv_any
  };
  event e

end

transition AddAdmin(admin: ByStr20)
  RequireContractOwner;
  has_admin <- exists admins[admin];
  match has_admin with
  | True =>
    error = AdminFoundError;
    Throw error
  | False =>
    admins[admin] := true
  end
end

transition ZRC6_MintCallback(to: ByStr20, token_id: Uint256, token_uri: String)
  e = {
    _eventname: "EvolveResultMint";
    to: to;
    token_id: token_id;
    token_uri: token_uri
  };
  event e
end