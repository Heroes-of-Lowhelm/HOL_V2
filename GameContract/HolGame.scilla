(* SPDX-License-Identifier: MIT *)
scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import IntUtils ListUtils 

library HolGame
let zero_address = 0x0000000000000000000000000000000000000000
let one = Uint256 1
let zero = Uint128 0
let hundred = Uint128 100
let ten = Uint256 10
let true = True
let false = False
let empty_string = ""
let one_msg = 
    fun (msg : Message) => 
        let nil_msg = Nil {Message} in
        Cons {Message} msg nil_msg   

(* Dummy user-defined ADT *)


type Error =
| CodeIsOwner
| NotAdminError
| AdminFoundError
| RequestAmountExceedErr

let make_error =
    fun (result : Error) =>
        let result_code = 
        match result with
        | CodeIsOwner                => Int32 -1
        | NotAdminError                => Int32 -2
        | AdminFoundError => Int32 -3
        | RequestAmountExceedErr => Int32 -4
        end
        in
        { _exception : "Error"; code : result_code }

(***************************************************)
(*             The contract definition             *)
(***************************************************)
contract HolGame 
(
    contract_owner: ByStr20
)

(* Mutable fields *)
(* Set for admins
  contract_owner is the admin by default *)
field admins: Map ByStr20 Bool = 
  let emp_map = Emp ByStr20 Bool in
  builtin put emp_map contract_owner true

(* $HOL token address *)
field hol_token_address: ByStr20 = zero_address
(* $CAST token address *)
field cast_token_address: ByStr20 = zero_address
(* Map user address => token address => balance *)
field account_balances: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(error: Error)
    e = make_error error;
    throw e
end



procedure IsNotOwner(address: ByStr20)
    is_owner = builtin eq contract_owner address;
    match is_owner with
    | False =>
        err = CodeIsOwner;
        ThrowError err
    | True =>
    end
end

(* Check is the address is admin or not *)
procedure IsAdmin()
  has_admin <- exists admins[_sender];
  match has_admin with
  | True =>
  | False =>
    error = NotAdminError;
    ThrowError error
  end
end


(***************************************)
(*             Transitions             *)
(***************************************)
(* This transition is invoked when depositing tx to the game contract is found *)
(* @param: to - User address that funds are deposited  *)
(* @param: token_address - Token address that user deposited  *)
(* @param: amount - Token amount that user deposited  *)
(* @Requirements: *)
(* - `_sender` must be the contract Admin. *)
transition DepositFund(to: ByStr20, token_address: ByStr20, amount: Uint128)
    IsAdmin;
    origin_amount <- account_balances[to][token_address];
    match origin_amount with
    | Some value =>
        new_amount = builtin add value amount;
        account_balances[to][token_address] := new_amount
    | None =>
        account_balances[to][token_address] := amount
    end
    
end


(* This transition is invoked when user request to withdraw*)
(* @param: to - User address *)
(* @param: token_address - Token address*)
(* @param: amount - Token amount *)
(* @Requirements: *)
(* - `_sender` must be the contract Admin. *)
transition WithdrawFund(to: ByStr20, token_address: ByStr20, amount: Uint128)
    IsAdmin;
    origin_amount <- account_balances[to][token_address];
    match origin_amount with
    | Some value =>
        insufficient = builtin lt value amount;
        match insufficient with
        | True =>
            error = RequestAmountExceedErr;
            ThrowError error
        | False =>
            new_amount = builtin sub value amount;
            account_balances[to][token_address] := new_amount;
            (* Transfer funds to user accounts *)
            msg = {
                _tag: "Transfer";
                _recipient: token_address;
                _amount: zero;
                to: to;
                amount: amount
            };
            msgs = one_msg msg;
            send msgs;
            e = {
                _eventname: "WithdrawSuccess";
                to: to
            };
            event e
        end
    | None =>
        error = RequestAmountExceedErr;
        ThrowError error
    end
end


transition AddAdmin(admin: ByStr20)
  IsNotOwner _sender;
  has_admin <- exists admins[admin];
  match has_admin with
  | True =>
    error = AdminFoundError;
    ThrowError error
  | False =>
    admins[admin] := true
  end
end

transition SetHolAddress(hol_address: ByStr20)
    IsNotOwner _sender;
    hol_token_address := hol_address
end

transition SetCastAddress(cast_address: ByStr20)
    IsNotOwner _sender;
    cast_token_address := cast_address
end

transition TransferSuccessCallBack(sender: ByStr20, recipient: ByStr20, amount: Uint128)

end